SED:BASICS: CHEAT SHEET by gv
http://sed.sourceforge.net/grabbag/tutorials/sedfaq.txt
http://sed.sourceforge.net/grabbag/tutorials/
http://sed.sourceforge.net/sed1line.txt
http://stackoverflow.com/questions/83329/how-can-i-extract-a-range-of-lines-from-a-text-file-on-unix
http://www.theunixschool.com/2014/08/sed-examples-remove-delete-chars-from-line-file.html
http://www.theunixschool.com/2012/06/sed-25-examples-to-delete-line-or.html
man sed and info sed. Especially info has tons of examples and special cases.

Read Sed Online Cheat Sheets in terminal : curl -sL -o- http://sed.sourceforge.net/sed1line.txt |less

For a detailed explanation of BRE and ERE (basic and extended regular expressions) see info sed at the relevant chapter.

##SED REGEX
The usuall group match with () seems to work better with sed -e and escaped parenthesis \(\)
Or sed -E /(..)\1/
# echo -e "abcd\nacvfdtt\ntert" |sed -e '/\(.\).*\1/d'    ---> abcd  #deletes words with duplicate letters using basic regex
# echo -e "abcd\nacvfdtt\ntert" |sed -E '/(.).*\1/d'      ---> abcd  #tha same as above with extender regex

##SEPARATORS 
All tutos describe operations with /. Slash can be replaced with any character (i.e ! or #) to make reading easier.
Actually is not only a visual help but can become quite a functional trick.
If the search terms, regexs contain chars same as delimiter, you need to escape them.
But if you apply a different delimiter you can avoid the escaping.

For example this tricky sed usage replace strange chars like slashes without the need to escape slashes since the delimiter is different.
a="https://www.google.gr";echo " log <sitepath />/<sitename />/platform_dir/logs/nginxerror.log" | sed -r "s#<sitepath /># $a #"  --> log  https://www.google.gr /<sitename />/platform_dir/logs/nginxerror.log

##INFO SED NOTICE:
info advises that other chars like % or ; etc when used as delimiters , first delimiter should start with \.
That means that sed '/word/p' ==> sed '\%word%p'

##SED USE EXTERNAL VARIABLE (i.e $line,$text,etc - defined before sed)
You just need to double quote the whole sed expression instead of single quotes.
Alternativelly you can use double quotes only at var but you need also to apply single quotes outside the double quotes.
i.e sed 's/'"$a"'/something/g' file

##MODIFIERS (see also info sed)
/REGEXP/I : I is for case insestive. Don't confuse with i which is operation insert
/REGEXP/M : Multiline mode - cause match of regexp including new lines before/after regexp - ^$ not operating - use \` and \' instead

##NON-Greedy / LAZY Regex Operation
In perl and grep -P we have the use of ? advising "non greedy" operation.
Sed .* works always in greedy mode = match . as much as possible 

Example file : <h2 id="customer-id">192238</h2>
With sed , we can simulate the non-greedy by negation
sed -r "s/^<.[^>]*>/FOO/" file1  ----> FOO192238</h2> 
Regex Explained : match beginning (^) string with < followed by any char (.) excluding > ([^>]) for zero or more times (*) ending at >
This replaces the whole <h2 id="customer-id"> with FOO
The negation concept is match as many chars excluding the first found [^>]. 
Without this exclusion the whole line (since it ends with >) will be replaced by FOO.
Greedy regex s/^<.*>/FOO/ will catch the whole line up to last > : Whole <h2 id="customer-id">192238</h2> --> becomes FOO

In Perl , we would use something like s/^<.*>?/FOO/ and the non-greedy operator ? would instruct Perl to make a lazy match (not up to the last >)

##COMMANDS OVERVIEW
:  # label
=  # line_number
a  # append_text_to_stdout_after_flush
b  # branch_unconditional             
c  # range_change                     
d  # pattern_delete_top/cycle          
D  # pattern_ltrunc(line+nl)_top/cycle 
g  # pattern=hold                      
G  # pattern+=nl+hold                  
h  # hold=pattern                      
H  # hold+=nl+pattern                  
i  # insert_text_to_stdout_now         
l  # pattern_list                       
n  # pattern_flush=nextline_continue   
N  # pattern+=nl+nextline              
p  # pattern_print                     
P  # pattern_first_line_print          
q  # flush_quit                        
r  # append_file_to_stdout_after_flush 
s  # substitute                                          
t  # branch_on_substitute              
w  # append_pattern_to_file_now         
x  # swap_pattern_and_hold             
y  # transform_chars 
~  # In range denotes "every XX lines" i.e sed '1~4d' list : "starting from line 1, taking every 4th".
{} # group commands. For example sed -n '5000p;q' (print and quit) does not work but sed -n '5000{p;q}' works fine.

/regex/! # negates regex = NOT Operation i.e sed '/abc/!d' : delete all lines that DO NOT contain /abc/ regex = keep only /abc/ lines = sed -n '/abc/p'
/regex/I # case insensitive regex match (gnu) --- > echo ONE TWO | sed "s/one/unos/I"      # prints "unos TWO"

's/replace-this/with-that/g' : replace this with that. 
Last /g is for 'global' = all occurences in the same line (not in whole file - sed is a line tool). 
Can be /4=fourth occurence found in the same line or even /2g=global after second occurence found in the same line

/regex/{s/this/that/g;} : Replace only if regex is found in the line
/regex/!{s/this/that/g;} : Replace this with that in all lines except line containing regex
5!s/ham/cheese/  : except on line 5, replace 'ham' with 'cheese'
'.../p' : print (force print when -n is used). some times requires space ('/.../ p'). Also !p for not print. Combine with -n to disable global printing and print specific lines/patterns that /p applies.
'..../d' : delete . Also !d for not delete. Combine /d with missing -n to see the input with the deletions.
'N': N command Reads next line into the pattern space.

##SED CLI SWITCHES
-n: not printing/quiet. If missing the input is printed.

-e: sed expression follows. Can be used multiple times for multiple expressions

-i: instant infile edit

-f: read commands from file. Command should not include the word sed, i.e s/e/E/g and not sed 's/e/E/g'

-z: use \0 (null) as record separator. Can fool sed to treat the whole file as a big string / big line with \n chars as part of the line as soon as the file does not contain real null chars.
Examples: 
sed 's/AAA/XXX/2g'   ---> will replace 2nd AAA and then all AAA found on the same -one- line (\n separated by default)
sed -z 's/AAA/XXX/2g' ---> will replace 2nd and then global/all AAA found in any line, since the whole file is considered to be one big line up to \0 or EOF

SED:CHEAT SHEET TXT 2 MANPAGE FORMATTING
##READ THIS CHEAT FILE WITH MAN PAGES:
http://technicalprose.blogspot.gr/2011/06/how-to-write-unix-man-page.html
man formatting: man 7 man
groff programming: http://web.cecs.pdx.edu/~trent/gnu/groff/groff.html#IDX123
man pages making: https://liw.fi/manpages/
https://linux.die.net/man/1/help2man

##WORKING COMMAND:
man --nj <(h=".TH man 1 2017 1.0 cheats page";sed "1i $h" cheatsheets/utils*gv.txt |sed 's/^UTILS:/.SH UTILS:/g; s/^$/\.LP/g; s/^##/\.SS /g; s/\\/\\e/g;G' |sed 's/^$/\.br/g')
You can also combine with --nh 
PS: man options --nj = not auto justified , --nh = not auto break words with hyphen on line changes.

##MAN AND GROFF/troff require special handling.
man ignores normal line feeds at end of lines ($); empty lines (^$) are recognized and displayed
Line feeds in man pages can be done by inserting .br between two lines.
More .br in series of lines are ignored by man and got intepreted as a single line feed - not multiple new lines.
Man pages should start with a .TH line
Man sections / header start with .SH. 
Subsection start with .SS. Alternativelly you can use .B to make this line bold. .B follows text identation - .SS has it's own idents.
The backslash \ works as escape in groff, so you need to escape the backslash with \e (or \\ can also work)
The example tr -d '\n' will become tr -d '\en' with \e escaping, or will become tr -d '\\n' with \\ escaping.

First sed  inserts a ".TH" as very first line in stream.
Then sed replaces capitalized  headers in file (format i.e BASH:) and insert .SH in front of them (i.e SED:BASICS becomes .SH SED:BASICS)
Then sed inserts .LP in the existing empty lines (^$) of original file. This forces man to preserve the empty line and consider the following lines as a new paragraph.
(previously i was injecting a temp pattern like ---- that was removed afterwards)
Then sed inserts a .SS in front of all the lines that start with ## and are considered as subheaders.
Then sed replaces existing backslashes in txt file with \e. So a description/example like \n will become \en and will be displayed like \n
and replace them with a temp pattern ---
Then using sed G option we double all lines = double file spacing => a new line is inserted after every line in file

This sed creates a new stream which is then piped to a new sed.
New sed adds .br in every empty line that was created by G action before. Old new lines contain .LP (or --- in prev versions) and are not affected. 

So at the end of the day we have a man page compatible file like
#.SH SED:BASICS
#Line1: tr -d '\en'
#.br
#Line2
#.br
#.LP
#.br
#Line3
#.br
#Line4

Man displays the file as it would display in any editor , in the old file classic txt format:
#SED:BASHICS (in bold!)
#Line1: tr -d '\n'
#Line2
<empty line>
#Line3
#Line4

##LIGHT CONVERSIONS
man --nh --nj <(sed 's/^SED:/.SH SED:/g; G' cheatsheets/sed*gv.txt)
man --nh --nj <(sed 's/^BASH:/.SH BASH:/g; s/^$/---/g;G' cheatsheets/bash*gv.txt |sed 's/^$/\.br/g; s/^---$//g')
man --nh --nj <(sed 's/^SED:/.SH SED:/g; s/^$/---/g;G' cheatsheets/sed*gv.txt |sed 's/^$/\.br/g; s/^---$//g')
----------------------------------------------------------------------------------------------------------------------------------------
SED:PRINT 
##FIND AND PRINT ENTRIES FROM CHEATSHEETS TXT FILES
sed -n '/SED:PRINT.*line.*/,/# -----/p' ./cheatsheets/sed*gv*.txt
sed -n '/JOIN/,/# ----/p' ./cheatsheets/*

##PRINT RANGE
sed -n '/regexp/p' #grep emulation - Print lines matching regex
sed -n '8,12p' #print from line 8 up to 12
sed -n '16224,16482p;16483q' file #mind the 16483q command (quit). Variables: sed -n "$FL,$LL p" file.txt
sed -n '8,/pattern/p' #from 8th line up to pattern
sed '/regex/,+5' #match /regex/ plus the next 5 lines (or EOF, whichever comes first).
sed -n '/word1/,/word2/p' #from word 1 up to first match of word2. Some times a space is required before p (/ p) = awk '/Tatty Error/,/suck/' a.txt
sed '/pattern1/,/pattern2/!d;/pattern2/q' file #Print from pat1 to pat2 and quit. Usefull if pattern1 and/or pattern2 repeats in file.
sed -n '/pattern1/,/pattern2/p;/pattern2/q' file #Same as above - print from pat1 to pat2 and quit.
sed -n '/pattern/,$p' file #from pattern ip to EOF = last \n. Also can use a starting line i.e '10,$p'
sed -n '/Description/,/$\/n/p'  - Print from regex match up to last \n
sed -n '1,/WORD/p' file # Print from 1st line up to pattern word
sed -n '/regexp/!p' #match lines NOT containing regexp (grep -v operation)
sed -n '1,/regexp/!p' #exclude line 1 up to regexp and print the rest
sed -n '/regexp/,$!p' a.txt  #exclude from regexp up to EOF and print the rest.
sed -n 'ADDR1,+N'  #Matches ADDR1 and N lines following ADDR1, i.e sed -n '6,+2p'. ADDR1 can be a line number or a pattern
sed -n '/regexp/{g;1!p;};h' #Print line before regex (not including the line with regex)
sed -n '/regexp/{n;p;}' 	#Print line after regex (not including the line with regex)
read -a arr -p "Enter line numbers: " ;sed -n "${arr[*]/%/p;}" infile  #Prints lines acc to user input.Based on bash echo "${arr[*]/%/p;}" -->1p; 3p; 5p; 7p;
sed '1~3d' file      # delete every 3d line, starting with line 1 --> deletes lines 1, 4, 7, 10, 13, 16, ...
sed '0~3d' file      # deletes lines 3, 6, 9, 12, 15, 18, ...
sed -n '2~5p' file   # print every 5th line, starting with line 2 ---> prints lines 2, 7, 12, 17, 22, 27, ...


##PRINT IN REVERSE = tac emulation
http://stackoverflow.com/questions/12833714/the-concept-of-hold-space-and-pattern-space-in-sed
sed -n '1!G;h;$p'
--------------------------------------------------------------------------------------------------------------------------------------
SED:REPLACE (s/original/replace/) AND INSERT
Also see: http://unix.stackexchange.com/questions/112023/how-can-i-replace-a-string-in-a-files

sed  -n 's/Tatty Error/suck/p' a.txt ## This one replaces Tatty Error with word suck and prints the whole changed line
echo "192.168.1.0/24" | sed  -n 's/0.24/2/p' 
sed -i 's/foo\(.*baz\)/bar\1/' file  ##Replace foo with bar only if there is a baz later on the same line:
sed -Ei 's/foo|bar|baz/foobar/g' file ##Replace any of foo, bar or baz with foobar
sed '/regex/!{s/this/that/g;}' : Replace this with that in all lines except line containing regex
sed '5!s/ham/cheese/'  : except on line 5, replace 'ham' with 'cheese'

##REPLACE CHARS WITH REGEX
See info sed - Regular Expressions
echo "abc %-= def." | sed 's/\b/X/g' ---> XabcX %-= XdefX. #\b = word bountary - \B all but not word boundary
echo "abc %-= def." | sed 's/\b/"/g' ---> "abc" %-= "def". #Insert double quotes with \b word bountary
echo "abc %-= def." | sed 's/\w/X/g' ---> XXX %-= XXX.   #\w = word match - \W all but not word
echo "abc %-= def." | sed 's/\s/X/g' ---> abcX%-=Xdef.   #\s = all whitespace - \S all but not whitespace
echo "abc %-= def." | sed 's/\</X/g' ---> Xabc %-= Xdef. #match beginning of word. Use \> to match end of word
sed -E -n '/^(.)o\1$/p' ---> matches words starting with any letter , followed by letter o - followed by a letter same as first (\1)
sed -E -n '/^(.)(.)(.)\3\2\1$/p' --> searches for 6-letter palindromes: first 3 letters are 3 subexpressions, followed by 3 back-references in reverse order

##REPLACE MULTIPLE REPLACE OPERATIONS: replace with different strings
You can combine sed commands: sed -i 's/foo/bar/g; s/baz/zab/g; s/Alice/Joan/g' file ##/g means global = all matches in file

##USE EXTENDER REGEX GROUPS TO SED REPLACE
$ a="define('DB_NAME', 'wordpress');";b="george"; echo "$a" |sed -E "s/(define.*)(\x27DB_NAME\x27, )(.*)(\)\;)/\1\2\'$b\'\4/g"  ##define('DB_NAME', 'george');
sed -i "s/define('DB_NAME', '.*');/define('DB_NAME', 'foobar');/" file

##SED REPLACE A STRING IN A LINE WITH PATTERN: 
sed -e '/^400/ s/,\{10\}$//' -e '/^300/ s/,\{5\}$//' -e '/^210/ s/,\{2\}$//'
above sed removes 10chars from end in line starting with 400, removes 5 chars at line starting 300 etc.

##REPLACE FIRST OCCURENCE OF A PATTERN (as) in every line with an increasing number 
while read line;do sed 's/as/'"$(( ++count ))"'/1' <<< "$line";done < source_file > target_file

##REPLACE SPECIAL CHARS LIKE BACKSLASH AND SINGLE QUOTES
Backslash has a special meaning = escape.
If your file/stream contains backslashes is a kind of pain to correctly match them and replace them.
More pain if the old text/new text also contain backslashes.
Similar story for single quotes.
In  such cases is quite usefull to refer to the special chars with their hex ascii value.
Back slash is \x5c and single quote is \x27

See for example this alias that makes single quotes escaping with backslashes:
alias esc_single_quotes='sed "s|\x27|\x5c\x5c\x27|g"'
echo "this is 'something'" ---> this is 'something' #text is containing single quotes.
echo "this is 'something'" |esc_single_quotes ---> this is \'something\' #replaced text should contain backslash + single quote in order to be sent to other apps with single quotes escaped.

##TEXT REPLACE MORE EXAMPLES 
Consider file containing:
ltm node /test/10.90.0.1 {
   address 10.90.0.1
}

.B 1. Lets suppose you want to add at the end of address %200
sed '/address/ s/$/%200/' a.txt
s = replace, $= end of line

Alternatives
str="address 10.90.0.1";newstr=$(awk -F"." '{print $1"."$2"."$3"."$4"%200"}'<<<$str);echo $newstr 
awk '/address/ && sub("$","%200") || 1' file.txt

.B 2. Lets suppose you want to replace the last digit with .20
sed '/address/ s/.[0-9]*$/.20/' a.txt
.[0-9]*$ = regex = starts with dot, contains numbers in range 0-9, multiple numbers (*) and then EOL ($)
alternatives
str="address 10.90.0.1";newstr=$(awk -F"." '{print $1"."$2"."$3".20"}'<<<$str);echo $newstr


##DELETE TEXT INSIDE MULTI LINE FILE - enclosed by curly brackets
This is {
the multiline
text file }
that wants
{ to be
changed
} anyway.

Output:
This is 
that wants
 anyway
 
Command:
$ sed ':again;$!N;$!b again; s/{[^}]*}//g' file
:again;$!N;$!b again; #This reads the whole file into the pattern space.
:again #is a label.  N reads in the next line.  
$!b again #branches back to the again label on the condition that this is not the last line.

s/{[^}]*}//g #This removes all expressions in braces.

Alternative:
sed '/{/{:1;N;s/{.*}//;T1}' multiline.file
started since line with { and get the next line (N) until substitution ({}) can be made 
( T means return to mark made by : if substitution isnt made)

http://unix.stackexchange.com/questions/71670/add-in-begining-to-selected-lines-in-file?rq=1

##REPLACE DASH IN STRING
String: #  1  2016-05-31-1003-57S._BKSR_003_CM6
$ sed 's/..$/-\0/g' <(cut -d- -f1-4 <(cut -d" " -f5- file.txt)) #use >newfile at the end to send the results to a new file
Output : 2016-05-31-10-03

Alternatives:
$ cut --output-delimiter='-' -c7-19,20-21 file.txt
$ while IFS= read -r line;do line="${line:6:13}-${line:14:2}";echo $line;done<file.txt
$ awk '{print substr($3,0,13)"-"substr($3,14,2)}' file.txt

## REPLACE STRING AFTER PATTERN MATCH
You can combine sed words search (/word1/,/word2/) and then you can continue on the same line to perform replace with usual s/old/new/
Input Example:
priority = 0
host = True

[shovel]
group = 
enabled = 0

Target : Change value of shovel enabled (from 0 to 1)

Command: sed '/\[shovel\]/,/^$/ s/enabled = 0/enabled = 1/' file
First part=/\[shovel\]/,/^$/ : from word [shovel] up to the next empty line (empty lines contain just start(^) and end ($) chars)
Second part=s/enabled = 0/enabled = 1/ : usual sed replace in form s/old/new

## REPLACE AFTER A RANGE WITH PATTERNS MATCH :
sed '/(/,/)/s/line/newline/g' #replaces line0-1-2-etc with newline0-1-2-etc in a file where first line and last line are in format (line0 ... up to lineX)
split to understand: the fine part is /(/,/)/ = /(/ , /)/
insteaf of 'p' at the end we use s/old/new/ for replace.

## REPLACE TEXT ON THE NEXT LINE OF PATTERN MATCH
Input:
client_encryption_options:
    enabled: false
    
sed '/^client_encryption_options:/,+1s/enabled:.*/enabled: true/' file #Mind the +1s trick to catch next line from patter

## REPLACE / insert text with multiline text stored in a file/var
http://stackoverflow.com/questions/42355276/using-multiline-variable-in-sed-command/42356901#42356901
The whole story for sed to be able to insert multiline text in another file is that this new multiline text must have actually literral \n for line breaks.

$ a=$(tr '\n' '\\' <file3 |sed 's#[\]$##' |sed "s#[\]#\0n#g") ##Convert new lines to a single \, remove this slash from the end , convert all backslashes to literal \ + n
#Alternative : a=$(tr '\n' '\\' <file3 > >(sed 's#[\]$##' |sed "s#[\]#\0n#g"))
#Alternative : a=$(sed "s#[\]#\0n#g" <(sed 's#[\]$##' <(tr '\n' '\\' <file3)))
$ echo "$a"
apples\noranges\nbananas\ncarrots  ##Original file3 has apples/oranges/bananas/carrots in seperate lines.
$ sed "2i $a" file4  ##Insert contents of variable $a before line2

##INSERT TEXT IN THE MIDDLE OF A FILE - before pattern match
http://stackoverflow.com/questions/42381852/sed-append-before-the-last-occurrence-of-a-character/42387699#42387699
$ sed -n '/class Foo2 {/,/^}$/{s/^}$/Insert here\n\0/};p' file
Assume a file with various classes in the format
public class Foo {
   // Some code
   // There will be functions here, so there are other {}
}

Above sed will match range from pattern class Foo2 { up to first alone } (closure of class) , and will insert a text before the closing } - Actually will replace the class closing } (^}$) with mytext & new line & replaced part \0 = ^}$
Was tested here: http://www.tutorialspoint.com/execute_bash_online.php?PID=0Bw_CjBb95KQMQ2FfcV9NdHdrOEE


##INSERT LINE FROM ANOTHER FILE IN THE CURRENT FILE
http://unix.stackexchange.com/questions/355524/i-want-to-add-n-lines-from-a-filesay-file1-into-another-file-below-the-n-o

sed '/^animal/IR File1' File2
I: Case insensitive
R: Queue a line of filename to be read and inserted into the output stream at the end of the current cycle, or when the next input line is read. 
Note that if filename cannot be read, or if its end is reached, no line is appended, without any error indication.

Example:
$ cat File1 
This Dog
This Cat
This Duck
This Horse

$ cat File2
Animal Name
AniMal Type
AnIMal Class
animal Brand

$ sed '/^animal/IR File1' File2
Animal Name
This Dog
AniMal Type
This Cat
AnIMal Class
This Duck
animal Brand
This Horse


##REPLACE HTML / XML ID TAGS
Generally , the use of a proper xml/html parser is suggested for parsing such kind of data. 
For simple operations you can use something like this:
cat <<EOF >file1
<h1 id="name">John Smith</h1>
<h2 id="customer-id">192238</h2>
<h3 id="current-date">Thu 13 Apr 2017</h3>
EOF
id="customer-id"

sed -r "/id=\"$id\"/ s/(^<.*id=)[^>]*>/\1\"FOO\">/" <file1
#Output of second line: <h2 id="FOO">192238</h2>
#Line1 and Line3 are printed unchanged - as input is provided.

sed -r "/id=\"$id\"/ s/^<.[^>]*>/<FOO>/" file1
#Output of second line: <FOO>192238</h2>

sed -r "/id=\"$id\"/ s/^<.[^>]*>/FOO/" file1
#Output of second line : FOO192238</h2>                                                                                                 


##MORE XML TAGS REPLACEMENT
$ cat file9
 <SubRecord1>
 <Property Name=Name>My Main Search Keyword</Property>
 <Property Name=Prompt>Dummy</Property>
 <Property Name=Default>Value i'm Concerned to Modify</Property>
 </SubRecord1>
 <SubRecord2>
 <Property Name=Name>My Main Search Keyword</Property>
 <Property Name=Prompt>Dummy</Property>
 <Property Name=Default>Do not Modify</Property>
 </SubRecord2>

$ sed -r '/\bSubRecord1\b/!b;n;n;n;s/(<Property Name=Default>)(.*)(<\/Property>)/\1AAAA\3/' file9   #Go to third line after SubRecord1
 <SubRecord1>
 <Property Name=Name>My Main Search Keyword</Property>
 <Property Name=Prompt>Dummy</Property>
 <Property Name=Default>AAAA</Property>
 </SubRecord1>
 <SubRecord2>
 <Property Name=Name>My Main Search Keyword</Property>
 <Property Name=Prompt>Dummy</Property>
 <Property Name=Default>Do not Modify</Property>
 </SubRecord2>
 
TIP: The use of word boundaries \b ensures that sed pattern /SubRecord/ (if supplied) will not match SubRecord1 or SubRecord2

##DELETE / REPLACE NEW LINES WITH SED
By default the syntax sed 's/\n//g' file does not work due to the fact that sed works one line at the time.

Workarounds:
perl -pe 's/\n//g' file* ---> works perfectly and removes all new lines from one or more files.
find . -type f -name 'file*' -exec bash -c 'tr "\n" " " <$0 >$0.new' {} \;  ---> replace new lines with space in many files.
sed 'N;s/\n/_/g' file   ---> Replaces only the next new line (N=append next line to sed working space);
sed 'N;N;s/\n/_/g' file ---> Replaces the next two new lines. for a file having one\ntwo\nthree\nfour --> one_two_three\nfour
sed ':begin;$!N;s/\n/ /;tbegin'  ---> Replaces all new lines with space (using labels and jumps...)

---------------------------------------------------------------------------------------------------------------------------
SED:EXAMPLES BY UNIX SCHOOL
.B See: http://www.theunixschool.com/2014/08/sed-examples-remove-delete-chars-from-line-file.html

SED:DELETE 
##TO REMOVE 1st character in every line:
sed 's/^.//' file 
or 
sed  's/.//' file  #mind the absence of /g modifier (=global replacement)

## TO REMOVE LAST CHARACTER OF EVERY LINE : 
$ sed 's/.$//' file

## TO REMOVE THE 1st and last character of every line in the same command: 
$ sed 's/.//;s/.$//' file

## TO REMOVE FIRST CHARACTER ONLY IF IT IS A SPECIFIC CHARACTER: 
$ sed 's/^F//' file #Removes Lines starting with F

## TO REMOVE LAST CHARACTER ONLY IF IT IS A SPECIFIC CHARACTER: 
$ sed 's/x$//' file #removes last character if is x

## TO REMOVE 1st 3 characters of every line: 
$ sed 's/...//' file #OR# $ sed -r 's/.{3}//' file

## TO REMOVE LAST N CHARACTERS OF EVERY LINE: 
$ sed -r 's/.{3}$//' file

## TO REMOVE EVERYTHING EXCEPT THE 1st n characters in every line: 
$ sed -r 's/(.{3}).*/\1/' file
.* -> matches any number of characters.
first 3 characters matched are grouped using parantheses. 
In the replacement, by having \1 only the group is retained, leaving out the remaining part.

##  SIMILARLY , to remove everything except the last n characters in a file: 
$ sed -r 's/.*(.{3})/\1/' file

## TO REMOVE MULTIPLE CHARACTERS PRESENT IN A FILE: 
$ sed 's/[aoe]//g' file

## TO REMOVE A PATTERN  : 
$ sed 's/lari//g' file

## TO DELETE ONLY NTH OCCURRENCE OF A CHARACTER IN EVERY LINE: 
$ sed 's/u//2' file #replaces two u and stops. /g replaces all . Leave it blank replace only the first u found in line.

## TO DELETE EVERYTHING IN A LINE FOLLOWED BY A CHARACTER: 
$ sed 's/a.*//' file #In Word RedHat this Returns RedH

## TO REMOVE ALL DIGITS PRESENT IN EVERY LINE OF A FILE: 
$ sed 's/[0-9]//g' file

## TO REMOVE ALL LOWER CASE ALPHABETS PRESENT IN EVERY LINE: 
$ sed 's/[a-z]//g' file #in word Linux this returns L

## TO REMOVE ALL ALPHA-numeric characters present in every line: 
$ sed 's/[a-zA-Z0-9]//g' file

## TO REMOVE A CHARACTER IRRESPECTIVE OF THE CASE: 
$ sed 's/[uU]//g' file

## DELETE A PARTICULAR LINE : 
$ sed '1d' file OR  $ sed '3d' file OR $ sed '$d' file (last line) OR sed '2,4d' file (range) OR sed '1d;$d' file (first and last line)
Tip: replace d with !d to invert the action = delete lines other than those with !d.

##DELETE ALL LINES BEGINNING WITH 'L'  /OR/ ending with 'x' character: 
$ sed '/^L/d' file /OR/ sed '/x$/d' file /OR/ sed '/[xX]$/d' file (both x and X) 

##DELETE ALL BLANK LINES IN THE FILE
$ sed '/^$/d' file

##DELETE ALL LINES WHICH ARE EMPTY OR WHICH CONTAINS JUST SOME BLANK SPACES:
$ sed '/^ *$/d' file

##DELETE THE LINES CONTAINING THE PATTERN 'Unix'.
$ sed '/Unix/d' file #Use !d to delete line NOT containing the pattern Unix.

##DELETE THE LINES CONTAINING THE PATTERN 'Unix' OR 'Linux':
$ sed '/Unix\|Linux/d' file #In some sed OR | is not working - use two expressions (not a pipe)

##DELETE THE LINES STARTING FROM THE 1st line till encountering the pattern 'Linux':
$ sed '1,/Linux/d' file

##DELETE THE LINES STARTING FROM THE PATTERN 'Linux' till the last line:
$ sed '/Linux/,$d' file

##DELETE THE LAST LINE ONLY IF IT CONTAINS THE PATTERN 'AIX':
$ sed '${/AIX/d;}' file /OR/ sed '${/AIX\|HPUX/d;}' file (two patterns with or)

##DELETE THE LINES CONTAINING THE PATTERN 'Solaris' only if it is present in the lines from 1 to 4.
$ sed '1,4{/Solaris/d;}' file

##DELETE THE LINE CONTAINING THE PATTERN 'Unix' and also the next line:
$ sed '/Unix/{N;d;}' file
N command reads the next line in the pattern space. d deletes the entire pattern space which contains the current and the next line.

##DELETE ONLY THE NEXT LINE CONTAINING THE PATTERN 'Unix', not the very line:
$ sed '/Unix/{N;s/\n.*//;}' file
with s/ we delete from the newline character till the end, which effective deletes the next line after the line containing the pattern Unix.

##DELETE THE LINE CONTAINING THE PATTERN 'Linux', also the line before the pattern:
$ sed -n '/Linux/{s/.*//;x;d;};x;p;${x;p;}' file | sed '/^$/d'

In order to delete the line prior to the pattern,we store every line in a buffer called as hold space. 
Whenever the pattern matches, we delete the content present in both, the pattern space which contains the current line, the hold space which contains the previous line.
'x;p;' ; This gets executed for every line. x exchanges the content of pattern space with hold space. p prints the pattern space. 
As a result, every time, the current line goes to hold space, and the previous line comes to pattern space and gets printed. 
When the pattern /Linux/ matches, we empty(s/.*//) the pattern space, and exchange(x) with the hold space(as a result of which the hold space becomes empty) and delete(d) the pattern space which contains the previous line. 

And hence, the current and the previous line gets deleted on encountering the pattern Linux. The ${x;p;} is to print the last line which will remain in the hold space if left.
The second part of sed is to remove the empty lines created by the first sed command

##DELETE ONLY THE LINE PRIOR TO THE LINE CONTAINING THE PATTERN  'Linux', not the very line:
$  sed -n '/Linux/{x;d;};1h;1!{x;p;};${x;p;}' file

This is almost same as the last one with few changes. On encountering the pattern /Linux/, we exchange(x) and delete(d). As a result of exchange, the current line remains in hold space, and the previous line which came into pattern space got deleted.
1h;1!{x;p;} -  1h is to move the current line to hold space only if it first line. Exchange and print for all the other lines. This could easily have been simply: x;p . The drawback is it gives an empty line at the beginning because during the first exchange between the pattern space and hold space, a new line comes to pattern space since hold space is empty.

## DELETE ONLY THE LINE PRIOR TO THE LINE CONTAINING THE PATTERN  'Linux', not the very line:
$  sed -n '/Linux/{x;d;};1h;1!{x;p;};${x;p;}' file

## DELETE THE LINE CONTAINING THE PATTERN 'Linux', the line before, the line after:
$ sed -n '/Linux/{N;s/.*//;x;d;};x;p;${x;p;}' file | sed '/^$/d'

## TO REMOVE THE 1st field or column (comma separated text):
$ sed 's/[^,]*,//' file

## TO DELETE THE 2nd field /OR/ To print only the second field
$ sed 's/,[^,]*,/,/' file  /OR/  sed 's/[^,]*,\([^,]*\).*/\1/' file

## DELETE THE FIRST LINE OF THE FILE:
$ sed '1d' file
---------------------------------------------------------------------------------------------------------------------------------------
SED:PRINT 
##PRINT FIRST / last line of the file: 
$ sed -n '1p' file  / sed -n '$p' file 

## PRINT LINES WHICH DOES NOT X / do contain 'ux':
$ sed -n '/X/!p' file / $ sed -n '/[ux]/p' file

## PRINT LINES WHICH END WITH 'x' or 'X' / Beginning with 'A' or 'L'
$ sed -n '/[xX]$/p' file   /   sed -n '/^A\|^L/p' file
Some sed version does not accept | (or). Use two patterns instead.

## PRINT EVERY ALTERNATE LINE (skip one line):
$ sed  'n;d' file
n command prints the current line, and immediately reads the next line into pattern space. d command deletes the line present in pattern space. In this way, alternate lines get printed.

Similarly sed  'n;n;N;d' file print every two lines

##PRINT LINES ENDING WITH 'X' within a range of lines:
$ sed -n '/Unix/,${/X$/p;}' file

The range of lines being chosen are starting from the line containing the pattern 'Unix' till the end of the file($). The commands present within the braces are applied only for this range of lines. 
Within this group, only the lines ending with 'x' are printed. 
Refer this to know how to print a range of lines using sed from example 5 onwards.

##PRINT RANGE OF LINES EXCLUDING THE STARTING AND ENDING LINE OF THE RANGE:
$ sed -n '/Solaris/,/HPUX/{//!p;}' file
The range of lines chosen is from 'Solaris' to 'HPUX'. 
The action within the braces is applied only for this range of lines. 
If no pattern is provided in pattern matching (//), the last matched pattern is considered. 
For eg, when the line containing the pattern 'Solaris' matches the range of lines and gets inside the curly braches, since no pattern is present, the last pattern (solaris) is matched. 
Since this matching is true, it is not printed(!p), and the same becomes true for the last line in the group as well.

## TO PRINT ONLY THE LAST FIELD, OR remove all fields except the last field:
$ sed 's/.*,//' file

##TO PRINT ONLY THE 1st field:
$ sed 's/,.*//' file

## PRINT /delete only the line containing 'Gmail'. In other words, to simulate the grep or grep -v command:
$ sed '/Gmail/p' file - For delete use /d instead of /p

##PRINT LINES TILL YOU ENCOUNTER A SPECIFIC PATTERN, say till 'Yahoo' is encountered.
$ sed  '/Yahoo/q' file  #q = quit if pattern / expression matched. Without -n option in sed, lines up to Yahoo are printed (default action of sed is to print).

## TO PRINT THE FIRST 3 lines, or from lines 1 through 3:
$ sed -n '1,3p' file #Alternative : sed '3q' file

##PRINT THE FIRST LINE OF THE FIRST FILE ('one.txt') and the last line of the last file ('three.txt').  
Use '-s' to reverse this behavior.
sed -n  '1p ; $p' one.txt two.txt three.txt
PS: 'sed' treats multiple input files as one long stream.

##DELETE LINES 30 to 35:
sed '30,35d' input.txt

##PRINT LINES 30 to 35:
sed -n '30,35p' input.txt

##PRINT ALL INPUT UNTIL A LINE STARTING WITH THE WORD 'foo' is found.
sed '/^foo/q' input.txt
---------------------------------------------------------------------------------------------------------------------------------------
SED:REPLACE 
##TO INSERT A NEW COLUMN AT THE END(last column) :
$ sed 's/.*/&,A/' file
The regex (.*) matches the entire line and replacing it with the line itself (& also \0 works) and the new field = letter A

##TO INSERT A NEW COLUMN IN THE BEGINNING(1st column):
$ sed 's/.*/A,&/' file

## TO PRINT THE ENTIRE FILE CONTENTS:
$ sed '' file

## TRANSILETERATE - tr simulation. Replace a set of chars with onether set of chars.
echo "All day  and all day" | sed 'y/aA/Bb/'
>bll dBy  Bnd Bll dBy
All character of a will replaced with B
All characters of A will replaced with b
In file usage makes global substitution by default.

## REPLACE RANGE OF LINES 2nd to 9th lines with the word 'hello':
sed '2,9c hello'

##REPLACE THE WORD 'hello' with 'world' only on line 144:
sed '144s/hello/world/' input.txt 

##REPLACES THE WORD 'hello' with 'world' only in lines containing the word 'apple':
sed '/apple/s/hello/world/' input.txt

##REPLACES THE WORD 'hello' with 'world' only in lines NOT containing the word 'apple':
sed '/apple/!s/hello/world/' input.txt 

##REPLACES THE WORD 'hello' with 'world' only in all lines excluding lines 4 to 17:
sed '4,17!s/hello/world/' input.txt
---------------------------------------------------------------------------------------------------------------------------------------
SED:INSERT 
##INSERT TEXT TO THE END OF FILE - after last line
sed -i -e "\$aTEXTTOEND" <filename>
OR
sed '$s/$/texttoend/'
Tip: if instead $a you use i.e 4a text will append to 4th line

##INSERT TEXT TO THE START OF FILE - before first line
The command inserts a tag to the beginning of a file:

sed -i "1s/^/<?php /" file
sed "1i YourTextHere" or sed "1i $h" (with text in variable h)

##INSERT TEXT AFTER SECOND LINE:
sed '2a hello' OR sed "2a $var" for text in variable - mind the double quotes
Leading whitespaces after the 'a' command are ignored.  The text to add is read until the end of the line.

## INSERT TEXT BEFORE SECOND LINE:
sed '2i "George"' a.txt

##INSERT TEXT IN LINE BEFORE / after pattern
sed '/-----/i "George"' a.txt  OR sed '/-----/a "George"' a.txt
i : insert text before pattern , a : insert after pattern

## INSEERT A PATTERN AFTER THE (same) pattern
sed -i 's/\(Samsung\)/\1\n\1/' input.txt		#The parentheses capture the word, then \1 puts it back twice with a newline in between.

------------------------------------------------------------------------------------------------------------------------------
SED:ONELINER:SCRIPTS FOR SED (Unix stream editor)        Dec. 29, 2005
------------------------------------------------------------------------------------------------------------------------------
Compiled by Eric Pement - pemente[at]northpark[dot]edu        version 5.5

Latest version of this file (in English) is usually at:
   http://sed.sourceforge.net/sed1line.txt
   http://www.pement.org/sed/sed1line.txt

SED:ONELINERS:FILE SPACING:
## DOUBLE SPACE A FILE
sed G

## DOUBLE SPACE A FILE WHICH ALREADY HAS BLANK LINES IN IT. Output file should contain no more than one blank line between lines of text.
sed '/^$/d;G'

## TRIPLE SPACE A FILE
sed 'G;G'

## UNDO DOUBLE-spacing (assumes even-numbered lines are always blank)
sed 'n;d'

## INSERT A BLANK LINE ABOVE EVERY LINE WHICH MATCHES "regex"
sed '/regex/{x;p;x;}'

## INSERT A BLANK LINE BELOW EVERY LINE WHICH MATCHES "regex"
sed '/regex/G'

## INSERT A BLANK LINE ABOVE AND BELOW EVERY LINE WHICH MATCHES "regex"
sed '/regex/{x;p;x;G;}'

## INSERT AN EMPTY LINE EVERY TWO FULL TEXT LINES
sed 'n;G'
--------------------------------------------------------------------------------------------------------------------------------------
SED:ONELINERS:NUMBERING:

## NUMBER EACH LINE OF A FILE (simple left alignment). Using a tab (see note on '\t' at end of file) instead of space will preserve margins.
sed = filename | sed 'N;s/\n/\t/'

## NUMBER EACH LINE OF A FILE (number on left, right-aligned)
sed = filename | sed 'N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /'

## NUMBER EACH LINE OF FILE, but only print numbers if line is not blank
sed '/./=' filename | sed '/./N; s/\n/ /'

## COUNT LINES (emulates "wc -l")
sed -n '$='
--------------------------------------------------------------------------------------------------------------------------------------
SED:ONELINERS:SUBSTITUTE TEXT CONVERSION AND SUBSTITUTION 

## IN UNIX ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format.
sed 's/.$//'               # assumes that all lines end with CR/LF
sed 's/^M$//'              # in bash/tcsh, press Ctrl-V then Ctrl-M
sed 's/\x0D$//'            # works on ssed, gsed 3.02.80 or higher

## IN UNIX ENVIRONMENT: convert Unix newlines (LF) to DOS format.
sed "s/$/`echo -e \\\r`/"            # command line under ksh
sed 's/$'"/`echo \\\r`/"             # command line under bash
sed "s/$/`echo \\\r`/"               # command line under zsh
sed 's/$/\r/'                        # gsed 3.02.80 or higher

## IN DOS ENVIRONMENT: convert Unix newlines (LF) to DOS format.
sed "s/$//"                          # method 1
sed -n p                             # method 2

## IN DOS ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format.
Can only be done with UnxUtils sed, version 4.0.7 or higher. The
UnxUtils version can be identified by the custom "--text" switch
which appears when you use the "--help" switch. Otherwise, changing
DOS newlines to Unix newlines cannot be done with sed in a DOS
environment. Use "tr" instead.

sed "s/\r//" infile >outfile         # UnxUtils sed v4.0.7 or higher
tr -d \r <infile >outfile            # GNU tr version 1.22 or higher

## DELETE LEADING WHITESPACE (spaces, tabs) from front of each line aligns all text flush left
sed 's/^[ \t]*//'                    # see note on '\t' at end of file

## DELETE TRAILING WHITESPACE (spaces, tabs) from end of each line
sed 's/[ \t]*$//'                    # see note on '\t' at end of file

## DELETE BOTH LEADING AND TRAILING WHITESPACE FROM EACH LINE
sed 's/^[ \t]*//;s/[ \t]*$//'

## INSERT 5 blank spaces at beginning of each line (make page offset)
sed 's/^/     /'

## ALIGN ALL TEXT FLUSH RIGHT ON A 79-column width
sed -e :a -e 's/^.\{1,78\}$/ &/;ta'  # set at 78 plus 1 space

center all text in the middle of 79-column width. In method 1, spaces at the beginning of the line are significant, and trailing spaces are appended at the end of the line. 
In method 2, spaces at the beginning of the line are discarded in centering the line, and no trailing spaces appear at the end of lines.
sed  -e :a -e 's/^.\{1,77\}$/ & /;ta'                     # method 1
sed  -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/'  # method 2

## SUBSTITUTE (find and replace) "foo" with "bar" on each line
sed 's/foo/bar/'             # replaces only 1st instance in a line
sed 's/foo/bar/g'            # replaces ALL instances in a line
sed 's/foo/bar/4'            # replaces only 4th instance in the same line
sed 's/foo/bar/4g'            # replaces all instances after 4th instance in the same line
sed 's/\(.*\)foo\(.*foo\)/\1bar\2/' # replace the next-to-last case
sed 's/\(.*\)foo/\1bar/'            # replace only the last case

## SUBSTITUTE "foo" with "bar" ONLY for lines which contain "baz"
sed '/baz/s/foo/bar/g'

## SUBSTITUTE "foo" with "bar" EXCEPT for lines which contain "baz"
sed '/baz/!s/foo/bar/g'

## CHANGE "scarlet" or "ruby" or "puce" to "red"
sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'   # most seds
gsed 's/scarlet\|ruby\|puce/red/g'                # GNU sed only

## REVERSE ORDER OF LINES (emulates "tac")
## BUG/feature in HHsed v1.5 causes blank lines to be deleted
sed '1!G;h;$!d'               # method 1
sed -n '1!G;h;$p'             # method 2

## REVERSE EACH CHARACTER ON THE LINE (emulates "rev")
sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//'

## JOIN PAIRS OF LINES SIDE-by-side (like "paste")
sed '$!N;s/\n/ /'

## IF A LINE ENDS WITH A BACKSLASH, append the next line to it
sed -e :a -e '/\\$/N; s/\\\n//; ta'

## IF A LINE BEGINS WITH AN EQUAL SIGN, append it to the previous line and replace the "=" with a single space
sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'

## ADD COMMAS TO NUMERIC STRINGS, changing "1234567" to "1,234,567"
gsed ':a;s/\B[0-9]\{3\}\>/,&/;ta'                     # GNU sed
sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'  # other seds

## ADD COMMAS TO NUMBERS WITH DECIMAL POINTS AND MINUS SIGNS (GNU sed)
gsed -r ':a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta'

## ADD A BLANK LINE EVERY 5 lines (after lines 5, 10, 15, 20, etc.)
gsed '0~5G'                  # GNU sed only
sed 'n;n;n;n;G;'             # other seds

## ONE SUBSTITUTION MULTIPLE PATTERNS
sed -e '/patt1/' -e '/patt2/' -e 's/foo/bar/g'  #all seds, Replace foo with bar in lines with patt1 or patt2

sed -E '/patt1|patt2/s/foo/bar/g'               #GNU. Same operation as above.

sed -E '/patt1|patt2/! s/foo/bar/g'             #GNU. Replace foo with bar in lines NOT having patt1 or patt2 

sed -E '/patt1|patt2/b; s/foo/bar/g'            #Jump (with /b) to the undefined label and go to next line skipping substitution

sed -E '/patt1/b; /patt2/b; /start/,/end/b; s/foo/bar/g'                #Same as above. Skip substitution for three different cases (patterns & range)

sed '/#/ba ; /\/\//ba ; /\/\*\*/,/\*\*\//ba ; s/example/EXAMPLE/g; :a'  #Similar, but jumps to label a which is defined in the end = skip s/../../g

--------------------------------------------------------------------------------------------------------------------------------------
SED:ONELINERS:PRINT SELECTIVE PRINTING OF CERTAIN LINES:

## PRINT FIRST 10 lines of file (emulates behavior of "head")
sed 10q

## PRINT FIRST LINE OF FILE (emulates "head -1")
sed q

## PRINT THE LAST 10 lines of a file (emulates "tail")
sed -e :a -e '$q;N;11,$D;ba'

## PRINT THE LAST 2 lines of a file (emulates "tail -2")
sed '$!N;$!D'

## PRINT THE LAST LINE OF A FILE (emulates "tail -1")
sed '$!d'                    # method 1
sed -n '$p'                  # method 2

## PRINT THE NEXT-to-the-last line of a file
sed -e '$!{h;d;}' -e x              # for 1-line files, print blank line
sed -e '1{$q;}' -e '$!{h;d;}' -e x  # for 1-line files, print the line
sed -e '1{$d;}' -e '$!{h;d;}' -e x  # for 1-line files, print nothing

## PRINT ONLY LINES WHICH MATCH REGULAR EXPRESSION (emulates "grep")
sed -n '/regexp/p'           # method 1
sed '/regexp/!d'             # method 2

## PRINT ONLY LINES WHICH DO NOT MATCH REGEXP (emulates "grep -v")
sed -n '/regexp/!p'          # method 1, corresponds to above
sed '/regexp/d'              # method 2, simpler syntax

## PRINT THE LINE IMMEDIATELY BEFORE A REGEXP, but not the line containing the regexp
sed -n '/regexp/{g;1!p;};h'

## PRINT THE LINE IMMEDIATELY AFTER A REGEXP, but not the line containing the regexp
sed -n '/regexp/{n;p;}'

## PRINT 1 line of context before and after regexp, with line number indicating where the regexp occurred (similar to "grep -A1 -B1")
sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h

## GREP FOR AAA AND BBB AND CCC (in any order)
sed '/AAA/!d; /BBB/!d; /CCC/!d'

## GREP FOR AAA AND BBB AND CCC (in that order)
sed '/AAA.*BBB.*CCC/!d'

## GREP FOR AAA OR BBB OR CCC (emulates "egrep")
sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d    # most seds
gsed '/AAA\|BBB\|CCC/!d'                        # GNU sed only

## PRINT PARAGRAPH IF IT CONTAINS AAA (blank lines separate paragraphs)
HHsed v1.5 must insert a 'G;' after 'x;' in the next 3 scripts below
sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'

## PRINT PARAGRAPH IF IT CONTAINS AAA AND BBB AND CCC (in any order)
sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d'

## PRINT PARAGRAPH IF IT CONTAINS AAA OR BBB OR CCC
sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
gsed '/./{H;$!d;};x;/AAA\|BBB\|CCC/b;d'         # GNU sed only

## PRINT ONLY LINES OF 65 characters or longer
sed -n '/^.\{65\}/p'

## PRINT ONLY LINES OF LESS THAN 65 characters
sed -n '/^.\{65\}/!p'        # method 1, corresponds to above
sed '/^.\{65\}/d'            # method 2, simpler syntax

## PRINT SECTION OF FILE FROM REGULAR EXPRESSION TO END OF FILE
sed -n '/regexp/,$p'

## PRINT SECTION OF FILE BASED ON LINE NUMBERS (lines 8-12, inclusive)
sed -n '8,12p'               # method 1
sed '8,12!d'                 # method 2

## PRINT LINE NUMBER 52
sed -n '52p'                 # method 1
sed '52!d'                   # method 2
sed '52q;d'                  # method 3, efficient on large files

## BEGINNING AT LINE 3, print every 7th line
gsed -n '3~7p'               # GNU sed only
sed -n '3,${p;n;n;n;n;n;n;}' # other seds

## PRINT SECTION OF FILE BETWEEN TWO REGULAR EXPRESSIONS (inclusive)
sed -n '/Iowa/,/Montana/p'             # case sensitive
--------------------------------------------------------------------------------------------------------------------------------------
SED:ONELINERS:DELETE SELECTIVE DELETION OF CERTAIN LINES:

## PRINT ALL OF FILE EXCEPT SECTION BETWEEN 2 regular expressions
sed '/Iowa/,/Montana/d'

## DELETE DUPLICATE, consecutive lines from a file (emulates "uniq").
First line in a set of duplicate lines is kept, rest are deleted.
sed '$!N; /^\(.*\)\n\1$/!P; D'

## DELETE DUPLICATE, nonconsecutive lines from a file. Beware not to overflow the buffer size of the hold space, or else use GNU sed.
sed -n 'G; s/\n/&&/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P'

## DELETE ALL LINES EXCEPT DUPLICATE LINES (emulates "uniq -d").
sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'

## DELETE THE FIRST 10 lines of a file
sed '1,10d'

## DELETE THE LAST LINE OF A FILE
sed '$d'

## DELETE THE LAST 2 lines of a file
sed 'N;$!P;$!D;$d'

## DELETE THE LAST 10 lines of a file
sed -e :a -e '$d;N;2,10ba' -e 'P;D'   # method 1
sed -n -e :a -e '1,10!{P;N;D;};N;ba'  # method 2

## DELETE EVERY 8th line
gsed '0~8d'                           # GNU sed only
sed 'n;n;n;n;n;n;n;d;'                # other seds

## DELETE LINES MATCHING PATTERN
sed '/pattern/d'

## DELETE ALL BLANK LINES FROM A FILE (same as "grep '.' ")
## REMOVES NEW LINES BETWEEN LINES ACTUALLY
sed '/^$/d'                           # method 1
sed '/./!d'                           # method 2

## DELETE ALL CONSECUTIVE BLANK LINES FROM FILE EXCEPT THE FIRST; also
## DELETES ALL BLANK LINES FROM TOP AND END OF FILE (emulates "cat -s")
sed '/./,/^$/!d'          # method 1, allows 0 blanks at top, 1 at EOF
sed '/^$/N;/\n$/D'        # method 2, allows 1 blank at top, 0 at EOF

## DELETE ALL CONSECUTIVE BLANK LINES FROM FILE EXCEPT THE FIRST 2:
sed '/^$/N;/\n$/N;//D'

## DELETE ALL LEADING BLANK LINES AT TOP OF FILE
sed '/./,$!d'

## DELETE ALL TRAILING BLANK LINES AT END OF FILE
sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'  # works on all seds
sed -e :a -e '/^\n*$/N;/\n$/ba'        # ditto, except for gsed 3.02.*

## DELETE THE LAST LINE OF EACH PARAGRAPH
sed -n '/^$/{p;h;};/./{x;/./p;}'

--------------------------------------------------------------------------------------------------------------------------------------
SED:ONELINERS:SPECIAL APPLICATIONS:
## GET USENET/e-mail message header
sed '/^$/q'                # deletes everything after first blank line

## GET USENET/e-mail message body
sed '1,/^$/d'              # deletes everything up to first blank line

## GET SUBJECT HEADER, but remove initial "Subject: " portion
sed '/^Subject: */!d; s///;q'

## GET RETURN ADDRESS HEADER
sed '/^Reply-To:/q; /^From:/h; /./d;g;q'

## PARSE OUT THE ADDRESS PROPER. Pulls out the e-mail address by itself from the 1-line return address header (see preceding script)
sed 's/ *(.*)//; s/>.*//; s/.*[:<] *//'

## ADD A LEADING ANGLE BRACKET AND SPACE TO EACH LINE (quote a message)
sed 's/^/> /'

## DELETE LEADING ANGLE BRACKET & space from each line (unquote a message)
sed 's/^> //'

## REMOVE MOST HTML TAGS (accommodates multiple-line tags)
sed -e :a -e 's/<[^>]*>//g;/</N;//ba'

## EXTRACT MULTI-part uuencoded binaries, removing extraneous header info, so that only the uuencoded portion remains. 
Files passed to sed must be passed in the proper order. Version 1 can be entered from the command line; version 2 can be made into an executable Unix shell script. (Modified from a script by Rahul Dhesi.)
sed '/^end/,/^begin/d' file1 file2 ... fileX | uudecode   # vers. 1
sed '/^end/,/^begin/d' "$@" | uudecode                    # vers. 2

## SORT PARAGRAPHS OF FILE ALPHABETICALLY. Paragraphs are separated by blank lines. GNU sed uses \v for vertical tab, or any unique char will do.
sed '/./{H;d;};x;s/\n/={NL}=/g' file | sort | sed '1s/={NL}=//;s/={NL}=/\n/g'
gsed '/./{H;d};x;y/\n/\v/' file | sort | sed '1s/\v//;y/\v/\n/'

## ZIP UP EACH .TXT file individually, deleting the source file and setting the name of each .ZIP file to the basename of the .TXT file
(under DOS: the "dir /b" switch returns bare filenames in all caps).
echo @echo off >zipup.bat
dir /b *.txt | sed "s/^\(.*\)\.TXT/pkzip -mo \1 \1.TXT/" >>zipup.bat
--------------------------------------------------------------------------------------------------------------------------------------
SED:ONELINERS:TYPICAL USE: 
Sed takes one or more editing commands and applies all of them, in sequence, to each line of input. 
After all the commands have been applied to the first input line, that line is output and a second input line is taken for processing, and the cycle repeats. 
The preceding examples assume that input comes from the standard input device (i.e, the console, normally this will be piped input). 
One or more filenames can be appended to the command line if the input does not come from stdin. Output is sent to stdout (the screen). 

Thus:

cat filename | sed '10q'        # uses piped input
sed '10q' filename              # same effect, avoids a useless "cat"
sed '10q' filename > newfile    # redirects output to disk

For additional syntax instructions, including the way to apply editing commands from a disk file instead of the command line, consult 
"sed & awk, 2nd Edition," by Dale Dougherty and Arnold Robbins (O'Reilly, 1997; http://www.ora.com), 
"UNIX Text Processing," by Dale Dougherty and Tim O'Reilly (Hayden Books, 1987) 
or the tutorials by Mike Arst distributed in U-SEDIT2.ZIP (many sites). 

To fully exploit the power of sed, one must understand "regular expressions." For this, see "Mastering Regular Expressions" by Jeffrey Friedl (OReilly, 1997).

The manual ("man") pages on Unix systems may be helpful (try "man sed", "man regexp", or the subsection on regular expressions in "man ed"), but man pages are notoriously difficult. 
They are not written to teach sed use or regexps to first-time users, but as a reference text for those already acquainted with these tools.
--------------------------------------------------------------------------------------------------------------------------------------
SED:QUOTING SYNTAX: 
The preceding examples use single quotes ('...') instead of double quotes ("...") to enclose editing commands, since sed is typically used on a Unix platform. 
Single quotes prevent the Unix shell from intrepreting the dollar sign ($) and backquotes (`...`), which are expanded by the shell if they are enclosed in double quotes. 
Users of the "csh" shell and derivatives will also need to quote the exclamation mark (!) with the backslash (i.e., \!) to properly run the examples listed above, even within single quotes.

Versions of sed written for DOS invariably require double quotes ("...") instead of single quotes to enclose editing commands.

SED:USE OF '\t' IN SED SCRIPTS: 
For clarity in documentation, we have used the expression '\t' to indicate a tab character (0x09) in the scripts.
However, most versions of sed do not recognize the '\t' abbreviation, so when typing these scripts from the command line, you should press
the TAB key instead. '\t' is supported as a regular expression metacharacter in awk, perl, and HHsed, sedmod, and GNU sed v3.02.80.
--------------------------------------------------------------------------------------------------------------------------------------
SED:VERSIONS OF SED: 
Versions of sed do differ, and some slight syntax variation is to be expected. In particular, most do not support the use of labels (:name) or branch instructions (b,t) within editing commands, except at the end of those commands. 
We have used the syntax which will be portable to most users of sed, even though the popular GNU versions of sed allow a more succinct syntax. 
When the reader sees a fairly long command such as this:

   sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d

it is heartening to know that GNU sed will let you reduce it to:

   sed '/AAA/b;/BBB/b;/CCC/b;d'      # or even
   sed '/AAA\|BBB\|CCC/b;d'

In addition, remember that while many versions of sed accept a command like "/one/ s/RE1/RE2/", some do NOT allow "/one/! s/RE1/RE2/", which contains space before the 's'. 
Omit the space when typing the command.
--------------------------------------------------------------------------------------------------------------------------------------
SED:ONELINERS:OPTIMIZING FOR SPEED: 
If execution speed needs to be increased (due to large input files or slow processors or hard disks), substitution will be executed more quickly if the "find" expression is specified before giving the "s/.../.../" instruction. 

Thus:

   sed 's/foo/bar/g' filename         # standard replace command
   sed '/foo/ s/foo/bar/g' filename   # executes more quickly
   sed '/foo/ s//bar/g' filename      # shorthand sed syntax

On line selection or deletion in which you only need to output lines from the first part of the file, a "quit" command (q) in the script will drastically reduce processing time for large files. 

Thus:

   sed -n '45,50p' filename           # print line nos. 45-50 of a file
   sed -n '51q;45,50p' filename       # same, but executes much faster

If you have any additional scripts to contribute or if you find errors in this document, please send e-mail to the compiler. Indicate the version of sed you used, the operating system it was compiled for, and the nature of the problem. 

## TO QUALIFY AS A ONE-liner, the command line must be 65 characters or less. 

Various scripts in this file have been written or contributed by:
--------------------------------------------------------------------------------------------------------------------------------------
SED:ONELINERS:DOCS
More Docs: http://sed.sourceforge.net/
--------------------------------------------------------------------------------------------------------------------------------------

SED:REGEX VS PERL - DOMAIN NAME EXTRACT FROM URL
The sed operations can be done by perl -pe.
Actually perl support for regex is a bit better than sed.

One of most tricky sed usage is to use the s/pattern/replace format in order to perform easy grep regex matches.
Extended Regex Grouping with parenthesis allow to "divide" the pattern in parts that you can refer afterwards to them with \1,\2, etc
PS: to use regex groups you need sed -r (extended regex)

See this example:
$ a="http://unix.stackexchange.com/questions/ask"
$ sed -r 's#(.*//)(.*?)(/.*)#\2#' <<<"$a" ---> unix.stackexchange.com/questions
$ perl -pe 's#(.*//)(.*?)(/.*)#\2#' <<<"$a" ---> unix.stackexchange.com

The problem of sed is that matches .* in a greedy way. Actually matches all chars (.*) after first group
In regex, the use of ? operator after pattern multiplier (*,+,?,etc) is used to advise a lazy non-greedy regex match = 1st match
Sed regex in second group (.*?), ignores the non-greedy operator '?' and keeps providing wrong results.

Perl on the other hand handles correctly the non-greedy ? operator and second groups matches all chars between 1st and 3rd group.

##DOMAIN NAME EXTRACTION WITH SED - Workarounds
Since you can not do this sed+regex groups 
One work around to extract the domain name from sting $a is to use sed transliretate and subsitute.
Transiletarate the slash '/' to a new line or even to null which is more correct.
Both examples give the desired output = unix.stackexchange.com

echo "$a" |sed -n "y|/|\n|;s/.*\n\n//;P"				#This works due to P instead of p . P prints current pattern space up to first new line
echo "$a" |sed "y|/|\x00|;s/.*\x00\x00//;s/\x00.*//"	#This transliterates slash to null (\0) and then removes everything up to double null and then everything after first null up to the end.

Examining the null:
echo "$a" |sed "y|/|\x00|" |hexit
0000000  68  74  74  70  3a  00  00  75  6e  69  78  2e  73  74  61  63  6b  65  78  63  68  61  6e  67  65  2e  63  6f  6d  00  71  75
          h   t   t   p   :  \0  \0   u   n   i   x   .   s   t   a   c   k   e   x   c   h   a   n   g   e   .   c   o   m  \0   q   u
0000040  65  73  74  69  6f  6e  73  00  61  73  6b  0a
          e   s   t   i   o   n   s  \0   a   s   k  \n

echo "$a" |sed "y|/|\x00|;s/.*\x00\x00//" |hexit
0000000  75  6e  69  78  2e  73  74  61  63  6b  65  78  63  68  61  6e  67  65  2e  63  6f  6d  00  71  75  65  73  74  69  6f  6e  73
          u   n   i   x   .   s   t   a   c   k   e   x   c   h   a   n   g   e   .   c   o   m  \0   q   u   e   s   t   i   o   n   s
0000040  00  61  73  6b  0a
         \0   a   s   k  \n

echo "$a" |sed "y|/|\x00|;s/.*\x00\x00//;s/\x00.*//" |hexit
0000000  75  6e  69  78  2e  73  74  61  63  6b  65  78  63  68  61  6e  67  65  2e  63  6f  6d  0a
          u   n   i   x   .   s   t   a   c   k   e   x   c   h   a   n   g   e   .   c   o   m  \n

.B Domain Name Extraction Alternative Workaround
sed "s#.*//##;s#/.*##" 		#Deletes from start up to // and then from first slash / up to end=keeps the middle

##MORE ABOUT PERL
Actually the above perl example uses the s/pattern/replace format of sed , which works in exactly the same way as sed.

perl -pe 's#n#N#' <<<"$a" -----> http://uNix.stackexchange.com/questions/ask		#a simple replacement, using a different delimiter
perl -pe 's#n#N#g' <<<"$a" ----> http://uNix.stackexchaNge.com/questioNs/ask		#g = global replacements,like sed /g

## BSD REPLACEMENTS EXERCISE
Each line should be terminated with \r\n , but lines only with \n must be concatenated with previous line
Made easily with PERL, while non-gnu sed would have million of warnings:

echo -ne "abc\r\ndef\nijk\r\nlmn\r\n" |cat -vte
abc^M$
def$
ijk^M$
lmn^M$

echo -ne "abc\r\ndef\nijk\r\nlmn\r\n" |perl -pe "s/\r\n/\0/g;s/\n//g;s/\0/\r\n/g" |cat -vte
abc^M$
defijk^M$
lmn^M$
